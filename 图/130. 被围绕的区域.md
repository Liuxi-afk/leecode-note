## [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150)
给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域：

连接：一个单元格与水平或垂直方向上相邻的单元格连接。

区域：连接所有 'O' 的单元格来形成一个区域。

围绕：如果您可以用 'X' 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 'X' 单元格围绕。

通过 原地 将输入矩阵中的所有 'O' 替换为 'X' 来 捕获被围绕的区域。你不需要返回任何值。

## 核心原则
- ***遍历（迭代/递归）时尽量不要改变用于决定遍历流程的数据结构或状态；如果必须改动，要把“访问/临时状态”和“最终状态”分开，并确保修改不会影响还没访问到的分支***
### 常见禁忌与具体示例
1. 在 for / while 遍历列表时修改同一个列表（增删）
   ```python
   nums = [1,2,3,4]
    for x in nums:
    if x % 2 == 0:
        nums.remove(x)   # 错：正在遍历时修改列表
    # 结果可能不是预期
    ```

- **错题记录**



```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m,n = len(board),len(board[0])
        def dfs(i,j):
            if i < 0 or i >= m or j < 0 or j >= n:
                return False
            if board[i][j] == 'O':
                board[i][j] = '#'
        
                if not (dfs(i - 1,j) and dfs(i + 1,j) and dfs(i,j - 1) and dfs(i,j + 1)):
                    board[i][j] = 'O'   
                     return False
                board[i][j] = 'X'
            return True
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'O':
                    dfs(i, j)
```
