## [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150)
给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域：

连接：一个单元格与水平或垂直方向上相邻的单元格连接。

区域：连接所有 'O' 的单元格来形成一个区域。

围绕：如果您可以用 'X' 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 'X' 单元格围绕。

通过 原地 将输入矩阵中的所有 'O' 替换为 'X' 来 捕获被围绕的区域。你不需要返回任何值。

## 核心原则
- ***遍历（迭代/递归）时尽量不要改变用于决定遍历流程的数据结构或状态；如果必须改动，要把“访问/临时状态”和“最终状态”分开，并确保修改不会影响还没访问到的分支***
### 常见禁忌与具体示例
1. 在 for / while 遍历列表时修改同一个列表（增删）
   ```python
   nums = [1,2,3,4]
    for x in nums:
    if x % 2 == 0:
        nums.remove(x)   # 错：正在遍历时修改列表
    # 结果可能不是预期
    ```
2. 在递归过程中既有副作用（改变状态）又靠返回值判断复杂性质（比如是否触边）——易出错
   - 短路
   ```python
   # 误用 and 导致后面 dfs 根本不执行
   if not (dfs(a) and dfs(b) and dfs(c)):
      ...
   ```
   - 修正：分别执行并收集结果，或把所有子调用赋值为变量：
   ```python
   r1 = dfs(a); r2 = dfs(b); r3 = dfs(c)
   if not (r1 and r2 and r3):
      ...
   ```
3. 把“已访问标记”和“最终目标状态”合二为一
   - 错（混用标记）：
   ```python
   # 用 'X' 表示“已访问”，但 'X' 也是最终想得到的值
   board[i][j] = 'X'   # 访问标记 === 最终值
   ```
4. 共享可变默认参数 / 全局可变状态
   错:
   ```python
   def f(a, acc=[]):   # acc 是可变默认值，多个调用会共享它
      acc.append(a)
   ```
   正确:
   ```python
   def f(a, acc=None):
      if acc is None: acc = []
      acc.append(a)
   ```
   
### **错题记录**

- 思路:四个 DFS 都要走完整个连通区域，然后一起返回，最后由四个返回值决定当前格子是否被围住
> 对一个连通块进行 DFS，直到所有路径都递归完成之后，再综合结果判断这个连通块是否触边。
- 限制
   - 限制 1：短路逻辑无法让 4 个 DFS 一起执行
      - and 是短路逻辑。如果一个方向返回 False，后面方向不会执行。
   - 限制 2：每个 DFS 都会“独占整个连通块”
      - 假设你的板子上有连通块 B：当你从 (i,j) 调 dfs(i-1,j)：它会遍历整个块 B把所有 O 都标记、都处理、都改变了（你不管是标记‘#’还是改‘X’都影响结构）
      - 一次 DFS 就已经把区域遍历完了，不可能让下一次 DFS 再遍历同一个区域。
      - 希望四个 DFS 是“并行探索区域”，但实际上它们是按顺序执行的，并且第一次 DFS 就把棋盘状态改变了，使后 3 个失效
   - 限制 3：不能让 DFS 在“中途”修改棋盘然后正确回溯
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m,n = len(board),len(board[0])
        def dfs(i,j):
            if i < 0 or i >= m or j < 0 or j >= n:
                return False
            if board[i][j] == 'O':
                board[i][j] = '#'
        
                if not (dfs(i - 1,j) and dfs(i + 1,j) and dfs(i,j - 1) and dfs(i,j + 1)):
                    board[i][j] = 'O'   
                     return False
                board[i][j] = 'X'
            return True
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'O':
                    dfs(i, j)
```
- 修改后:
   - 先标记整块区域,整体地确认是否触边,是则还原为"O",否则改为"X"
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        m, n = len(board), len(board[0])

        def dfs(i, j, region):
            # 越界 -> 区域触边
            if i < 0 or i >= m or j < 0 or j >= n:
                return False
            
            if board[i][j] != 'O':
                return True

            board[i][j] = '#'  # 标记访问
            region.append((i, j))

            up    = dfs(i-1, j, region)
            down  = dfs(i+1, j, region)
            left  = dfs(i, j-1, region)
            right = dfs(i, j+1, region)

            return up and down and left and right

        for i in range(m):
            for j in range(n):
                if board[i][j] == 'O':
                    region = []
                    enclosed = dfs(i, j, region)  # 整个区域 DFS 完成后才返回

                    if enclosed:
                        for x, y in region:
                            board[x][y] = 'X'
                    else:
                        for x, y in region:
                            board[x][y] = 'O'
```

### 官解
> 思路:
- 本题要求将所有被字母 X 包围的字母 O都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。

注意到题目解释中提到：任何边界上的 O 都不会被填充为 X。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：
- 对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；
- 最后我们遍历这个矩阵，对于每一个字母：
   - 如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
   - 如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        m, n = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < m or not 0 <= y < n or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
        
        for i in range(m):
            dfs(i, 0)
            dfs(i, n - 1)
        
        for i in range(n - 1):
            dfs(0, i)
            dfs(m - 1, i)
        
        for i in range(m):
            for j in range(n):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```
作者：力扣官方题解
链接：https://leetcode.cn/problems/surrounded-regions/solutions/369110/bei-wei-rao-de-qu-yu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
