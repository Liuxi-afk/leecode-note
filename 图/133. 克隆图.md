## [133. 克隆图](https://leetcode.cn/problems/clone-graph/description/?envType=study-plan-v2&envId=top-interview-150)

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。
```python
class Node {
    public int val;
    public List<Node> neighbors;
}
```

## 深拷贝
- 深拷贝的核心目标
  - 生成一个完全独立的新对象（新对象和原对象的所有层级元素都不共享内存）
- 哈希表建立待拷贝对象与新对象的双射
  - 处理循环引用（比如 a.next = b 且 b.next = a，避免递归 / 迭代时无限循环）
  - 避免重复拷贝（比如一个对象被多个地方引用，只拷贝一次，保证新对象的内部结构一致）
### 初始答案

第一次遍历图建立双射,第二次遍历字典补充相邻点信息

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

from typing import Optional
class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return None
        dic = {}
        tmp = [node]
        while tmp:
            a = tmp.pop()
            dic[a] = [Node(a.val),a.neighbors]
            for key in a.neighbors:
                if key not in dic:
                    tmp.append(key)
        for val in dic.values():
            val[0].neighbors = [dic[x][0] for x in val[1]]
        return dic[node][0]
```
修改后答案

一次遍历图,在创建新对象建立双射的同时补充相邻点信息
```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

from typing import Optional
class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return None
        dic = {}
        tmp = [node]
        while tmp:
            a = tmp.pop()
            if a not in dic:
                dic[a] = Node(a.val)
            for key in a.neighbors:
                if key not in dic:
                    tmp.append(key)
                    dic[key] = Node(key.val)
                dic[a].neighbors.append(dic[key])
        return dic[node]
```
