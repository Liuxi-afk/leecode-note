# 动态规划

## 问题类型
- **重叠子问题**：原问题可以拆分成多个子问题，且这些子问题会被反复计算（比如斐波那契数列中，f(5) = f(4)+f(3)，f(4) = f(3)+f(2)，f(3) 被计算了两次）；
- **最优子结构**：原问题的最优解可以由子问题的最优解推导而来（比如 “从 A 到 B 的最短路径”，如果经过 C 点，那么 “A 到 C 的最短路径”+“C 到 B 的最短路径” 就是 A 到 B 的最短路径）。

## 核心思路：拆分 + 复用
- 拆分问题：把原问题（规模 n）拆成若干个规模更小的子问题（比如规模 n-1、n-2...）；
- 记录子问题答案：用一个 “状态容器”（如数组dp）存储每个子问题的最优解，避免重复计算；
- 递推求解：从子问题的最优解出发，推导出原问题的最优解（通过 “状态转移方程” 实现）。

## 动态规划三要素
### 第一要素：状态定义（State Definition）
> 「状态」是描述问题当前 “所处阶段” 的关键信息，是子问题的抽象表示。状态定义的核心是：用一个变量（或多个变量）描述当前的问题规模，且该变量能唯一确定子问题的最优解。
- **核心原则**：状态要能 “覆盖子问题的所有必要信息”，且能通过递推关联到更大的问题。

**例子 1：爬楼梯（LeetCode 70)**

问题：每次可以爬 1 或 2 阶，求爬到第 n 阶的不同方法数。
- 状态定义：dp[i] = 爬到第 i 阶的不同方法数。
  - 解释：i描述了问题规模（第 i 阶），dp[i]存储子问题的答案（方法数），且dp[i]能通过dp[i-1]（爬到 i-1 阶的方法数）和dp[i-2]（爬到 i-2 阶的方法数）推导而来。

**例子 2：0-1 背包（经典问题）**

问题：有 n 个物品，每个物品重量w[i]、价值v[i]，背包容量为 C，求能装入的最大价值（每个物品只能选一次）。
- 状态定义：dp[i][j] = 前 i 个物品中，选出若干个放入容量为 j 的背包，能得到的最大价值。
  - 解释：i（前 i 个物品）和j（背包容量 j）共同描述状态（二维状态），覆盖了 “选哪些物品” 和 “剩余容量” 的核心信息，dp[i][j]存储子问题的最大价值。
 
### 第二要素：状态转移方程（State Transition）
> 描述「当前状态的最优解」如何由「前一个 / 几个状态的最优解」推导而来的数学公式 —— 是 DP 的 “核心逻辑”，体现了子问题之间的关联。
- **核心思路**：考虑 “当前阶段的决策”，并基于决策拆分到子问题。比如 “选或不选”“走或不走”“加或不加” 等决策。

**例子 1：爬楼梯**
- 决策：爬到第 i 阶，最后一步只能是 “从 i-1 阶爬 1 阶” 或 “从 i-2 阶爬 2 阶”；
- 转移方程：dp[i] = dp[i-1] + dp[i-2]。
  - 解释：爬到 i 阶的方法数 = 爬到 i-1 阶的方法数（再爬 1 阶） + 爬到 i-2 阶的方法数（再爬 2 阶）。
**例子 2：0-1 背包**
- 决策：对于第 i 个物品，有两种选择 ——“选” 或 “不选”；
  - 不选第 i 个物品：dp[i][j] = dp[i-1][j]（前 i 个物品的最大价值 = 前 i-1 个物品在容量 j 下的最大价值）；
  - 选第 i 个物品：dp[i][j] = dp[i-1][j - w[i]] + v[i]（前 i 个物品的最大价值 = 前 i-1 个物品在容量 j-w [i] 下的最大价值 + 第 i 个物品的价值）；
- 转移方程：dp[i][j] = max(不选, 选) = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i])（注意：j <w [i] 时，只能不选，即dp[i][j] = dp[i-1][j]）。
> 转移方程必须 “无后效性”—— 即当前状态的推导只依赖于 “已解决的子问题状态”，不依赖于未来的状态（比如爬楼梯中dp[i]只依赖dp[i-1]和dp[i-2]，不依赖dp[i+1]）。
### 第三要素：边界条件（Base Case）
> 边界条件是「最小规模子问题的解」—— 是递推的 “起点”，没有边界条件，转移方程就无法启动（比如爬楼梯中，dp[1]和dp[2]就是最小子问题的解）。
**核心原则**：找到 “无需再拆分的最小子问题”，直接给出其答案（通常是规模为 0、1 的子问题）。

**例子 1：爬楼梯**
-最小子问题：
  - 爬到第 1 阶：只有 1 种方法（直接爬 1 阶）→ dp[1] = 1；
  - 爬到第 2 阶：有 2 种方法（1+1 或直接爬 2 阶）→ dp[2] = 2；
- 边界条件：dp[1] = 1, dp[2] = 2。
**例子 2：0-1 背包**
- 最小子问题：
  - 前 0 个物品（无物品可选）：无论背包容量 j 是多少，最大价值都是 0 → dp[0][j] = 0（j≥0）；
  - 背包容量 j=0（无法装任何物品）：无论前 i 个物品是什么，最大价值都是 0 → dp[i][0] = 0（i≥0）；
- 边界条件：dp[0][j] = 0, dp[i][0] = 0。
> 边界条件的错误会导致整个递推结果错误（比如爬楼梯中如果dp[1] = 0，后续所有dp[i]都会是 0）。
## 动态规划的解题步骤（落地流程）
1. **判断问题是否适合 DP：是否有重叠子问题和最优子结构；
2. **定义状态**：用dp[i]或dp[i][j]描述子问题，明确数组的含义；
3. **推导转移方程**：基于当前状态的决策，拆分到子问题，写出递推公式；
4. **确定边界条件**：给出最小子问题的解，确保递推能启动；
5. **计算最优解**：通过 “递推（迭代）” 或 “记忆化搜索（递归）” 计算dp数组，最终得到原问题的解。
