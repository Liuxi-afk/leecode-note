## [1. 两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-interview-150)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。



### 初次代码
> 思路:先用哈希表记录原始索引,然后排序nums,用双指针一遍遍历得出数值,再根据数值通过哈希表对应原始索引
- 问题:
  - 要求排序nums,时间复杂度达到 $O(n \log n)$
  - 先排完nums的哈希表后重复遍历获取对应索引

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        dicnums = {i:nums[i] for i in range(n)}
        nums.sort()
        p,q =0,n - 1
        sum1 = nums[p] + nums[q]
        while sum1 != target:
            if sum1 < target:
                p += 1
            if sum1 > target:
                q -= 1
            sum1 = nums[p] + nums[q]
        li = list(dicnums.values())
        for s in range(n):
            if li[s] == nums[p]:
                break
        for t in range(n - 1,- 1,- 1):
            if li[t] == nums[q]:
                break
        return [s,t]
```

### 改进后
> 思路:边存边查(避免了重复遍历,以及避免出现"target是两个相同的数值之和,而全存哈希表导致该数值只会存最后一个索引"的问题)
```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # 哈希表：存储{数值: 原索引}
        num_to_index = {}
        for idx, num in enumerate(nums):
            # 计算需要匹配的另一个数值
            complement = target - num
            # 若互补数值在哈希表中，返回结果
            if complement in num_to_index:
                return [num_to_index[complement], idx]
            # 若不在，将当前数值和索引存入哈希表
            num_to_index[num] = idx
        # 题目保证有解，无需处理无结果情况
        return []
```
