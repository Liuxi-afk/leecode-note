## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150)
给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。
- 平衡二叉树:平衡二叉树 是指该树所有节点的左右子树的高度相差不超过 1。

### 原始答案:
- 自上而下更新节点
思路:
- 要求每个节点左右两边节点高度相差不超过1-->即尽量保证每个节点左右两边节点数量相等-->即保证每次选取的节点为当前选取区间的中值-->采取分治思想,每次对上下两个区间进行二分确认left和right属性

代码逻辑:
- 先定初始节点
- 每次makeup迭代 通过left,right确定当前处理区间,i为当前cur节点索引,对和i索引不等的left,right取中点确认.left和.right属性,并将新节点带入下一次迭代
- 最终,i既与left相等又与right相等,无可更新属性,即 $left = right$ 则终止当前方向迭代
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        n = len(nums)
        o = (n - 1) // 2
        cur = head = TreeNode(nums[o])
        def makeup(cur,i,left,right):
            if left == right:
                return
            k,j = (left + i - 1) // 2,(right + i + 1) // 2
            if i != left:
                cur.left = TreeNode(nums[k])
                makeup(cur.left,k,left,i - 1)
            if i != right:
                cur.right = TreeNode(nums[j])
                makeup(cur.right,j,i + 1,right)
        makeup(cur,o,0,n - 1)
        return head
```

### 更改后:
- 每一次迭代确定一次当前区间的中间节点
- 自下而上返回子树
```python
from typing import List, Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # 辅助函数：基于子数组 [start, end] 构建平衡BST，返回根节点
        def build_balanced_bst(start: int, end: int) -> Optional[TreeNode]:
            # 边界：子数组为空，返回None（递归终止）
            if start > end:
                return None
            # 选子数组中点作为根（保证左右子树高度差≤1）
            # 若想选右中点（偶数长度时），可改为 mid = (start + end + 1) // 2
            mid = (start + end) // 2
            # 1. 创建当前子树的根节点
            root = TreeNode(nums[mid])
            # 2. 递归构建左子树（左子数组 [start, mid-1]）
            root.left = build_balanced_bst(start, mid - 1)
            # 3. 递归构建右子树（右子数组 [mid+1, end]）
            root.right = build_balanced_bst(mid + 1, end)
            # 4. 返回当前子树的根
            return root
        
        # 递归入口：整个数组 [0, len(nums)-1]
        return build_balanced_bst(0, len(nums) - 1)
```
