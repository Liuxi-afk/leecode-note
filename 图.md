## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-interview-150)
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

解题思路:
**找到一个陆地后，立即用 DFS/BFS 标记其所有相邻陆地为已访问，确保每个岛屿只计数一次。这是解决 “连通分量计数” 问题的标准思路（类似 “感染问题”）**
### DFS
**可以把"1"视为未探索的陆地,把"0"视为已探索的陆地/水,遍历列表**  
当前为"1"则岛屿数量+1,并且通过该地向临近四格探索,递归过程中不断将同一个搜索方向压入栈,为DFS
```python
def dfs(i,j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':#防溢出&检测未探索地块
                return
            grid[i][j] = '0'
            dfs(i - 1,j)
            dfs(i + 1,j)
            dfs(i,j - 1)
            dfs(i,j + 1)
```
``` python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        ans,m,n = 0,len(grid),len(grid[0])
        def dfs(i,j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
                return
            grid[i][j] = '0'
            dfs(i - 1,j)
            dfs(i + 1,j)
            dfs(i,j - 1)
            dfs(i,j + 1)
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    ans += 1
                    dfs(i,j)
        return ans
```
